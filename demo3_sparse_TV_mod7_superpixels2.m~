% Real data
%% demo2_sunsal_mscale
% =========================================================================
%
% Demo of example 2 (DC2) of the paper.
% 
% Modified by: Ricardo Borsoi, 2017
%   
%   Included a multiscale spatial regularization method based on the 
%   superpixel decomposition of the HSI, comparing with the SUnSAL 
%   and SUnSAL-TV results.
%   
%   The abundance image was the same as that of example 2 
%   of (Iordache et al. 2012).
% 
% 
% 
% =========================================================================








mkdir('examples/realImg')

%%

addpath real_data

load cuprite_ref.mat

% L
nl = Lines;
nc = Columns;
Yim = reshape(x',nl,nc,L);



imagesc(Yim(:,:,50))


% Yim = Yim(1:30,1:30,:);

nl = size(Yim,1);
nc = size(Yim,2);


% reorders
% Y = reshape()

Y = reshape(Yim, [size(Yim,1)*size(Yim,2) L])';





%%

%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% buid the dictionary 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
load USGS_1995_Library.mat
%  order bands by increasing wavelength
[dummy index] = sort(datalib(:,1));
A =  datalib(index,4:end);
names = names(4:end,:);


% % prune the library 
% % min angle (in degres) between any two signatures 
% % the larger min_angle the easier is the sparse regression problem
% min_angle = 4.44;       
% [A, index] = prune_library2(A,min_angle); % 240  signature 
% names = names(index',:);

% order  the columns of A by decreasing angles 
[A, index, angles] = sort_library_by_angle(A);
names = names(index',:);


A = A(BANDS,:);

% p = size(A,2);
n = size(A,2);

%%
% Apply the band-dependent correction strategy

[c] = calibrate_image_lib(A,Y);

load Cvec.mat

Y = diag(c)*Y;



%%



% Decompose the image into homogeneous regions and apply clustering
% individually 

addpath SLIC_DimensionReduction
addpath SSSE
addpath vlfeat-0.9.20

run('vlfeat-0.9.20/toolbox/vl_setup')


% 30db
lambda1_sp = 4e-3;
lambda2_sp = 5e-2;
beta       = 3;
slic_size  = 8;%1000%10
slic_reg   = 0.005;%0.005%0.00515;



% teste ------------
lambda1_sp = 4e-3;
lambda2_sp = 5e-2;
beta       = 3;
slic_size  = 8;%1000%10
slic_reg   = 0.005;%0.005%0.00515;


Y2 = reshape(Y', nl, nc, L);   
Y2a = Y2;

tic

% reorder and rescale data into 2-D array
[numRows,numCols,numSpectra] = size(Y2);
scfact = mean(reshape(sqrt(sum(Y2.^2,3)), numRows*numCols, 1));
Y2 = Y2./scfact;
imgVec = reshape(Y2, [numRows*numCols numSpectra]);

% compute superpixels
disp('Computing SLIC Superpixels...');
% tic; spSegs = vl_slic(single(Y2), 20, 0.005); toc % original params: 10, 0.01
% tic; spSegs = vl_slic(single(Y2), 5, 0.01); toc % original params: 15, 0.005
% spSegs = vl_slic(single(Y2), 5, 0.01); % original params: 15, 0.005
spSegs = vl_slic(single(Y2), slic_size, slic_reg);
numSuperpixels = double(max(spSegs(:)))+1; 

%%
% ------
% display image of superpixels (optional)
[sx,sy] = vl_grad(double(spSegs), 'type', 'forward') ;
s = find(sx | sy) ;

imgColor = Y2(:,:,[100 80 50]);
imgColor = uint8(255*(imgColor - min(imgColor(:)))./(max(imgColor(:))-min(imgColor(:))));
imgS = imgColor; 
imgS([s s+numel(imgColor(:,:,1)) s+2*numel(imgColor(:,:,1))]) = 0;
figure; imshow(1.5*imgS)
figure, imshow(imgColor)


% print('example1/realImg/img_example','-depsc')
% print('example1/realImg/img_example_sppx','-depsc')
% close all

%%

% ------
% Unmix the superpixels

Y3 = zeros(size(Y2));
avg_superpx = zeros(1, numSuperpixels+1, L);

for i=0:numSuperpixels
    [rowi, coli] = find(spSegs==i);
    
    for j=1:length(rowi)
        % Averages all pixels inside each superpixel
        if j == 1
            avg_superpx(1,i+1,:) = (1/length(rowi)) * Y2a(rowi(j),coli(j),:);
        else
            avg_superpx(1,i+1,:) = avg_superpx(1,i+1,:) + (1/length(rowi)) * Y2a(rowi(j),coli(j),:);
        end
    end
    
    % This is optional (for visualization)
    for j=1:length(rowi)
        Y3(rowi(j),coli(j),:) = avg_superpx(1,i+1,:);
    end
end

figure, imagesc(Y2(:,:,1))
figure, imagesc(Y3(:,:,1))


% Unmix each superpixel individually
% lambda = 1e-2;
% lambda1_sp = 0.25e-2;
[X_hat_l1_suppx] = sunsal(A,squeeze(avg_superpx)','lambda',lambda1_sp,'ADDONE','no','POSITIVITY','yes', ...
                       'TOL',1e-4, 'AL_iters',2000,'verbose','yes');

% Re-attribute the abundances for the entire matrix
temp = zeros(size(Y2,1), size(Y2,2), n);
for i=0:numSuperpixels
    [rowi, coli] = find(spSegs==i);
    
    % Attributes unmixing result to all pixels in a voxel
    for j=1:length(rowi)
        temp(rowi(j),coli(j),:) = X_hat_l1_suppx(:,i+1);
    end
end

X_hat_l1_spreg = reshape(temp, [size(Y2,1)*size(Y2,2) n])';


% beta = .3; %25; %25
% constrained least squares l2-l1                
% lambda = 10e-3;
[X_hat_l1_spreg] =  sunsal_spreg(A,Y,X_hat_l1_spreg,beta,'lambda',lambda2_sp,'ADDONE','no','POSITIVITY','yes', ...
                    'TOL',1e-4, 'AL_iters',2000,'verbose','yes');

toc

% SRE_l1_spreg = 20*log10(norm(XT,'fro')/norm(X_hat_l1_spreg-XT,'fro'))


% endmember no. 1 (tv_ni)
X_hat_l1_spreg_im = reshape(X_hat_l1_spreg', nl,nc,n);       
figure, imagesc(X_hat_l1_spreg_im(:,:,supp(5)))
title('Spreg - Frational abundance of endmember 5')











%% constrained least squares l2-l1   

% 30db:
lambda = 5e-2;



[X_hat_l1] =  sunsal(A,Y,'lambda',lambda,'ADDONE','no','POSITIVITY','yes', ...
                    'TOL',1e-4, 'AL_iters',2000,'verbose','yes');

% SRE_l1 = 20*log10(norm(XT,'fro')/norm(X_hat_l1-XT,'fro'))



%%

% 30db:
lambda = 4e-3;
lambda_TV = 10e-3;


tic
[X_hat_tv_ni,res,rmse_ni] = sunsal_tv(A,Y,'MU',0.05,'POSITIVITY','yes','ADDONE','no', ...
                               'LAMBDA_1',lambda,'LAMBDA_TV', lambda_TV, 'TV_TYPE','niso',...
                               'IM_SIZE',[nl,nc],'AL_ITERS',200,  'VERBOSE','yes');
   
toc
% SRE_tv_ni = 20*log10(norm(XT,'fro')/norm(X_hat_tv_ni-XT,'fro')); 
   



%%

figure %('Position',[1 1 scrsz(3)/2 scrsz(4)/2])

% subplot(151)
% imagesc(XT(:,1:100))
% title('spectral vectors (1;100)')

% subplot(152)
% imagesc(X_hat_cls(:,1:100))
% axis off
% title('CLS')

subplot(142)
imagesc(X_hat_l1(:,1:100))
axis off
title('SUnSAL')

subplot(143)
imagesc(X_hat_tv_ni(:,1:100))
axis off
title('SUnSAL-TV-NISO')

subplot(144)
imagesc(X_hat_l1_spreg(:,1:100))
axis off
title('Mscale-SprPx')




%%

% % % addpath fcls
% % % 
% % % options = optimoptions(@fmincon,'Algorithm','interior-point');
% % % 
% % % c = ones(L,1);
% % % x = zeros(p,nl*nc);
% % % 
% % % for i=1:50
% % %     costfx = @(X)(norm(A*X - diag(c)*Y, 2));
% % %     costfc = @(c)(norm(A*X - diag(c)*Y, 2));
% % %     
% % %     
% % % %     [x,fval] = fmincon(costfx,x,[],[],[],[], zeros(size(x)), 1e100*ones(size(x)),... 
% % % %        @nonlcon_fun, options);
% % %    
% % % %    [x,fval] = fmincon(costfx,x,[],[],[],[], zeros(size(x)), 1e100*ones(size(x)),... 
% % % %        [], options);
% % %    
% % %    
% % %     lambda = 0;
% % % %     [X] =  sunsal(A,diag(c)*Y,'lambda',lambda,'ADDONE','yes','POSITIVITY','yes', ...
% % % %                  'TOL',1e-4, 'AL_iters',5000,'verbose','yes');
% % %     [~, X] = estimateLinearModel(diag(c)*Y, A, true  );
% % %     
% % %     c = diag( (A*X*(Y')) ./ (Y*(Y')) );
% % %     
% % %     disp(i)
% % % end
% % % 
% % % 
% % % imagesc(X)
% % % 
% % % 
% % % figure, plot(c)

%%

% save('Cvec.mat','c')

%%

% costf = @(X,c)(norm(A*X-diag(c)*Y,2));
% X = p x nl*nc
% c = L x 1
% Xc = [X  [c ; 0]]
% costf = @(Xc)(norm(A*Xc(:,1:end-1) - diag(Xc(:,end))*Y, 2));
% costf = @(Xc)(norm(A*Xc(:,1:end-1) - diag(Xc(1:L,end))*Y, 2));



% % Xc2 = [X' ; c'], 
% costf = @(Xc)(norm(A*(Xc(1:end-1,:)') - diag(Xc(end,:))*Y, 2));


% if L > p
%     error('Not enough spectral bands!!')
% end
% 
% % x0 = [zeros(L,nl*nc)' ; ones(L,1)'];
% x0 = [zeros(p,nl*nc) [ones(L,1); zeros(p-L,1)]];


% Equality: Aeq*Xc(:) = beq
% The function c(x) represents the constraint c(x) <= 0. The function ceq(x) represents the constraint ceq(x) = 0.
% nonlcon = @(Xc)([-1e100*ones(size(x0)), [ones(1,p)*Xc(:,1:end-1)-ones(1,nl*nc)]]);
% nonlcon = @(Xc)([[-1], [ones(1,p)*Xc(:,1:end-1)-ones(1,nl*nc)]]);


% options = optimoptions(@fmincon,'Algorithm','interior-point');
% [x,fval] = fmincon(costf,x0,[],[],[],[], zeros(size(x0)), 1e100*ones(size(x0)),... 
%    @nonlcon_fun, options);
% 
% c = x(1:L,end);

% 
% Xc0 = fmincon(costf,x0,...
%     0, 0,...
%     ones(1,L), [ones(1,nl*nc) 0], ...
%     zeros(size(x0)), 1e10*ones(size(x0)));




% %%
% load PaviaU_gt.mat
% load PaviaU.mat
% load paviaU_EndmemberMatrix
% 
% 
% [N1,N2,L] = size(paviaU);
% N = N1*N2;
% Y = zeros(L,N);
% 
% 
% count = 1;
% for i=1:N1
%     for j=1:N2
%         
%     end
% end





